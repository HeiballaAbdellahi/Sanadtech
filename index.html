<!DOCTYPE html>
<html>
<head>
    <style>
        body {margin:0;}

.navbar {
  overflow: hidden;
  background-color: #333;
  position: fixed;
  top: 0;
  width: 100%;
}

.navbar a {
  float: left;
  display: block;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
  font-size: 17px;
}

.navbar a:hover {
  background: #ddd;
  color: black;
}

.main {
  padding: 16px;
  margin-top: 30px;
  height: 1500px; /* Used in this example to enable scrolling */
}
    </style>
</head>
<body>
    <div class="navbar">
        <a onclick="putSquare()">Placer Le carré</a>
        <a onclick="toLink()">Lier Les Carrés</a>
        <a onclick="clearCanvas()">Réinitialiser</a>
      </div>

<br>
<br>
<br>

    <canvas id="myCanvas" width="1000" height="1000"></canvas>
      

   
<script>
    var canvas = document.getElementById('myCanvas');
var context = canvas.getContext('2d');
//at the start
    let linked =false;//deactivate linking menue
    let placed =true;//activate placing menue
    //to activate linking function
    function toLink(){
        linked=true;
        placed=false;
    }
    //to activate putting funvtion
    function putSquare(){
        linked=false;
        placed=true;
    }
    //function to get the square of the position of the click
    function getSquare(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: 1 + (evt.clientX - rect.left) - (evt.clientX - rect.left)%10,
        y: 1 + (evt.clientY - rect.top) - (evt.clientY - rect.top)%10
    };
}
//link square function
function linkSquare(context, x, y){
    context.lineWidth = 4;
   context.strokeStyle = "#E50404"
   context.beginPath();
        context.moveTo(x, y);
        context.lineTo(300, 150);
        context.stroke();
   
}

//drow the grid on canvas
function drawGrid(context) {
    context.save()
    for (var x = 0.5; x < 1000; x += 100) {
      context.moveTo(x, 0);
      context.lineTo(x, 1000);
    }
    
    for (var y = 0.5; y < 1000; y += 100) {
      context.moveTo(0, y);
      context.lineTo(1000, y);
    }
    
    context.strokeStyle = "#ddd";
    context.stroke();

    context.setLineDash( [ 1, 4 ] )
    for (var x = 0.5; x < 1000; x += 10) {
      context.moveTo(x, 0);
      context.lineTo(x, 1000);
    }
    
    for (var y = 0.5; y < 1000; y += 10) {
      context.moveTo(0, y);
      context.lineTo(1000, y);
    }
    
    context.strokeStyle = "#ddd";
    context.stroke();
    context.restore();
}


//function to fill the square with interior color
function fillSquare(context, x, y){
    context.fillStyle = "#FFF2D6"
    context.fillRect(x-34,y-29,72-4,63-4);
}
//function to fill the square with the color that will be shown on the outline
function strokeSquare(context, x, y){
    context.fillStyle = "#777777"
    context.fillRect(x-36,y-31,72,63);
}


//drow grid call
drawGrid(context);

//function to clear the canvas
function clearCanvas(){
   // context.clearRect(0, 0, 1000, 1000); just to clear the canvas but reload will do the job
   // drawGrid(context)
    location.reload()
}

//list of direction to a square
let dirextion=[

]

//get a list of points between to points
const findway=(start,end)=>{
    for(var j = start.x; j < 1000; j += 100){
    dirextion.push({x:x,y:y});
}}

//check if square in the path 
const inwayx=(starty,endy,startx)=>{
    var virage=endy;
    if(starty<endy){
     for(var j = starty; j < endy+100; j += 100){
        if(findSquare({x:j,y:startx})){
            virage=j-100;
        }
    }}
    else {
        for(var j = starty; j > endy+100; j -= 100){
        if(findSquare({x:j,y:startx})){
            virage=j+100;
        }
    }}
     return virage; 
    }
   


//drow direction to a square
const draw=(start,end)=>{
	var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");
    ctx.lineWidth = 4;
    //generate a random color for the link
    var hue = 'rgb(' + (Math.floor(Math.random() * 256)) + ',' + (Math.floor(Math.random() * 256)) + ',' + (Math.floor(Math.random() * 256)) + ')';
    ctx.strokeStyle = hue;
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(start.x, inwayx(start.y,end.y,start.x));
    ctx.lineTo(end.x, inwayx(start.y,end.y,start.x));
    ctx.lineTo(end.x, end.y);
    ctx.stroke();
}

// list of points
let points=[

]


//list of squares
let squares=[

]

//find a square in list of squares added
const findSquare=(square)=>{
    let exists=false;
    for(let i in squares){
        if(squares[i].x==square.x && squares[i].y==square.y){
            exists=true;
        }
    }
    return exists;
}


//listner to the events 
canvas.addEventListener('click', function(evt) {
    //chck if placed is clicked
    if(placed){
        var mousePos = getSquare(canvas, evt);//turn the position of mouse to square
        const x=(Math.round(mousePos.x/100)*100);//turn the x to the nearest number to a multiple of 100
        const y=(Math.round(mousePos.y/100)*100);//turn the y to the nearest number to a multiple of 100

    if(!findSquare({x:x,y:y})){//check if the square deosnt aready exist 
        squares.push({x:x,y:y});//puch the square to the list of squars
        strokeSquare(context, x, y)//stroke it
        fillSquare(context, x, y)//file it
        console.log(squares)//to see the squares list in consol
    }
    };

    //chck if linked is clicked
    if(linked){
        var mousePos = getSquare(canvas, evt);//get square
        if(points.length==0){//check if points list has no points yet
        if(findSquare({x:(Math.round(mousePos.x/100)*100),y:(Math.round(mousePos.y/100)*100)})){//check if the place selected has a square in the squares table
        points.push({x:(Math.round(mousePos.x/100)*100),y:(Math.round(mousePos.y/100)*100)})//puch the first point to the points list
        context.fillStyle = "#F0D1BA"//just to light the selected square
        context.fillRect((Math.round(mousePos.x/100)*100)-34,(Math.round(mousePos.y/100)*100)-29,72-4,63-4);   
        }
    	}
    else if(points.length==1){//check if points list has only one point
        if(findSquare({x:(Math.round(mousePos.x/100)*100),y:(Math.round(mousePos.y/100)*100)})){//once again check if the secound place selected has a square in the squares table
        points.push({x:(Math.round(mousePos.x/100)*100),y:(Math.round(mousePos.y/100)*100)})//puch the secound point to the points list
        context.fillStyle = "#F0D1BA"//just to light the secound selected square
        context.fillRect((Math.round(mousePos.x/100)*100)-34,(Math.round(mousePos.y/100)*100)-29,72-4,63-4);  
        }
    	
    }
    draw(points[0],points[1])//call the finction to drow direction between the two points in the points list
    context.fillStyle = "#FFF2D6"//return the two square to their color
    context.fillRect((Math.round(points[0].x/100)*100)-34,(Math.round(points[0].y/100)*100)-29,72-4,63-4);
    context.fillRect((Math.round(mousePos.x/100)*100)-34,(Math.round(mousePos.y/100)*100)-29,72-4,63-4);
    points=[]

       
    }

    
    
}, false);


</script>

</body>
</html> 